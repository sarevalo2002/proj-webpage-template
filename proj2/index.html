<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2023</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Sebastian Arevalo</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>
    I implemented two main things in this project: A 3D-renderer utilizing Bezier curves, and a 3D-renderer utilizing triangle meshes. The renderer that utilizing Bezier curves took advantage of De Casteljau’s algorithm and (its separable application) to form both Bezier curves and Bezier surfaces, which allowed 3D objects to be rendered. The rendered utilizing triangle meshes was more integrated in this project, with the half-edge data structure allowing me to create a renderer that could find the norm of, flip, split, and conduct loop subdivision on the triangle meshes that made up the rendered 3D objects. This allowed me to easily manipulate the objects themselves to make them more realistic with smooth rounded edges while maintaining the general shape of the objects themselves. I found this project super fun, and I learned a lot, especially about utilizing separable 1D Bezier curves to form Bezier surfaces as well as how the process of loop subdivision works on triangle meshes. Before I was unsure exactly how we would go about finding multiple Bezier curves to create a Bezier surface, but after implementing it myself I learned how rather simple the whole procedure is, with a recursive approach that essentially simplifies the multi dimensional problem into the single dimensional one that we know how to solve. Meanwhile, for the loop subdivision algorithm, before implementing it myself I was completely lost on how it worked or what the specifics of the procedure were. But after taking some time and splitting the algorithm into easy to manage parts, I finally understand how loop subdivision works and what a few drawbacks of the algorithm are (such as how it handles sharp edges and corners), but also how pre-processing could mitigate these drawbacks. Overall super fun project and it made me even more excited to see what the course will introduce next.
</p>
<br>


<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


<b>
  Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.
</b>
<p>
    De Casteljau’s algorithm is a recursive process that utilizes conducting lerps of pairs of points at utilizing a range of t values between 0 and 1 to generate a new subset of points, with the final set of points used to construct Bezier curves. In order to implement this algorithm I implemented the function BezierCurve::evaluateStep, where I first created a new std::vector of Vector2D objects to hold the next set of points to be generated by the algorithm. Next I looped through the n current input points, conducting a lerp for every pair of points to generate n - 1 new points, finally returning the new set of points. By calling BezierCurve::evaluateStep multiple times until only one point for each t value remains, I can successfully construct Bezier curves.
</p>
<br>


<b>
  Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task1-1.png" align="middle" width="400px"/>
                    <figcaption>Generated 6 Points</figcaption>
                </td>
                <td>
                    <img src="images/task1-2.png" align="middle" width="400px"/>
                    <figcaption>6 Point Curve</figcaption>
                </td>
            </tr>
        </table>
    </div>

<br>

<b>
  Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve as well.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task1-1.png" align="middle" width="400px"/>
                    <figcaption>Level 0 Points</figcaption>
                </td>
                <td>
                    <img src="images/task1-2.png" align="middle" width="400px"/>
                    <figcaption>Level 0 Curve</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task1-3.png" align="middle" width="400px"/>
                    <figcaption>Level 1 Points</figcaption>
                </td>
                <td>
                    <img src="images/task1-4.png" align="middle" width="400px"/>
                    <figcaption>Level 1 Curve</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task1-5.png" align="middle" width="400px"/>
                    <figcaption>Level 2 Points</figcaption>
                </td>
                <td>
                    <img src="images/task1-6.png" align="middle" width="400px"/>
                    <figcaption>Level 2 Curve</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task1-7.png" align="middle" width="400px"/>
                    <figcaption>Level 3 Points</figcaption>
                </td>
                <td>
                    <img src="images/task1-8.png" align="middle" width="400px"/>
                    <figcaption>Level 3 Curve</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task1-9.png" align="middle" width="400px"/>
                    <figcaption>Level 4 Points</figcaption>
                </td>
                <td>
                    <img src="images/task1-10.png" align="middle" width="400px"/>
                    <figcaption>Level 4 Curve</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task1-11.png" align="middle" width="400px"/>
                    <figcaption>Level 5 Points</figcaption>
                </td>
                <td>
                    <img src="images/task1-12.png" align="middle" width="400px"/>
                    <figcaption>Level 5 Curve</figcaption>
                </td>
            </tr>
        </table>
    </div>

<br>


<b>
  Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter \(t\) via mouse scrolling.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task1-13.png" align="middle" width="400px"/>
                    <figcaption>New Points</figcaption>
                </td>
                <td>
                    <img src="images/task1-14.png" align="middle" width="400px"/>
                    <figcaption>New t-Value</figcaption>
                </td>
            </tr>
        </table>
    </div>

<br>


<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
<b>
  Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.
</b>
<p>
    The de Casteljau algorithm that we use to generate Bezier curves can be applied to each “plane” of points (utilizing a range of u values between 0 and 1) to generate a series of our typical Bezier curves, and then by applying the de Casteljau algorithm once more to the newly formed series of curves (utilizing a range of v values between 0 and 1) we can create a Bezier surface. In order to implement this algorithm, I first implemented the helper function BezierPatch::evaluateStep, which takes n three-dimensional points and conducts a lerp on each pair of points to return n - 1 new points. I then implemented another helper function BezierPatch::evaluate1D, which runs BezierPatch::evaluateStep continuously on a set of points until only one point remains, effectively finishing the implementation for the typical de Casteljau algorithm. Finally, I implemented the function BezierPatch::evaluate, which calls BezierPatch::evaluate1D on each “row” of points in our three-dimensional space with our u parameter in order to create the necessary series of Bezier curves, finally returning a final call to BezierPatch::evaluate1D on the points that make up the new series of Bezier curves with our v parameter which effectively creates a Bezier surface.
</p>
<br>


<b>
  Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task2-1.png" align="middle" width="400px"/>
                    <figcaption>Default Viewpoint</figcaption>
                </td>
                <td>
                    <img src="images/task2-2.png" align="middle" width="400px"/>
                    <figcaption>Different Viewpoint</figcaption>
                </td>
            </tr>
        </table>
    </div>

<br>


<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

<b>
  Briefly explain how you implemented the area-weighted vertex normals.
</b>
<p>
    To implement area-weighted vertex normals I first initialized a return point, and then I proceeded to loop through all adjacent faces utilizing a do while loop, taking advantage of the halfedge data structure to avoid checking boundary faces. For all valid faces, I found all 3 vertices of the triangle (v1, v2, v3) and computed its vertex normal (by finding the cross product of v1 - v2 and v1 - v3), and then added this vertex normal multiplied by the area (which was found by taking the norm of the vertex normal and dividing by 2) to my return point. Finally I returned a normalized version of my computed return point.
</p>
<br>


<b>
  Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use <kbd>Q</kbd> to toggle default flat shading and Phong shading.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task3-1.png" align="middle" width="400px"/>
                    <figcaption>Default Viewpoint</figcaption>
                </td>
                <td>
                    <img src="images/task3-2.png" align="middle" width="400px"/>
                    <figcaption>Smoother Version</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task3-3.png" align="middle" width="400px"/>
                    <figcaption>Different Viewpoint</figcaption>
                </td>
                <td>
                    <img src="images/task3-4.png" align="middle" width="400px"/>
                    <figcaption>Smoother Version</figcaption>
                </td>
            </tr>
        </table>
    </div>

<br>


<h3 align="middle">Part 4: Edge Flip</h3>
<b>
  Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.
</b>

    <div align="middle">
        <img src="images/task4-1.jpeg" align="middle" width="50%">
    </div>

<p>
    I first drew everything out (see drawing) and created a pair of connected triangles, labeling (with arbitrary values) the halfedges, vertices, edges, and faces. I then determined what each value had pointers to before and after the flip. This brings me to the actual code, where (after checking that e0 isn’t a boundary edge), I find the same mesh values as those in my drawing via finding e0’s halfedge, finding the rest of the halfedges with proper calls to twin() and next(), and then finding the vertices, edges, and faces with calls to vertex(), edge(), and face() on the relevant halfedges. Once I did this, it was as easy as utilizing setNeighbors and halfedge() to reassign pointers just like I had done in my drawing. I didn’t have to debug this task, but I think as far as implementation tricks go I’d say draw / write everything out first, and then utilize those values in the code to make the process straightforward and easy to read.
</p>
<br>


<b>
  Show screenshots of the teapot before and after some edge flips.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task4-2.png" align="middle" width="400px"/>
                    <figcaption>Default Viewpoint</figcaption>
                </td>
                <td>
                    <img src="images/task4-3.png" align="middle" width="400px"/>
                    <figcaption>After Edge Flips</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task4-4.png" align="middle" width="400px"/>
                    <figcaption>Different Viewpoint</figcaption>
                </td>
                <td>
                    <img src="images/task4-5.png" align="middle" width="400px"/>
                    <figcaption>After Edge Flips</figcaption>
                </td>
            </tr>
        </table>
    </div>

<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    While I didn’t actually have to debug this task (since I spent a good amount of time preparing and writing everything out before actually coding), I was stuck on how to reassign halfedge elements to the vertices, edges, and faces. It took me a good while to figure out that even though the halfedge() function in Vertex, Edge, and Face returned its respective halfedge, it could also be used for reassignment (props to the GUIDE TO IMPLEMENTING EDGE OPERATIONS ON A HALFEDGE DATA STRUCTURE document).
</p>
<br>


<h3 align="middle">Part 5: Edge Split</h3>
<b>
  Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task5-1.jpeg" align="middle" width="400px"/>
                    <figcaption>Typical Split Implementation</figcaption>
                </td>
                <td>
                    <img src="images/task5-2.jpeg" align="middle" width="400px"/>
                    <figcaption>Boundary Split Implementation</figcaption>
                </td>
            </tr>
        </table>
    </div>

<p>
    I first drew everything out for both the case in which the edge was a boundary, and the case in which the edge wasn’t a boundary (see drawings), labeling (with arbitrary values) the halfedges, vertices, edges, and faces. I then determined what each value had pointers to before and after the split in both cases. This brings me to the actual code, where I first check if the edge e0 is a boundary edge. While the number of values I compute is different based on the outcome of this boundary check, my splitting process is generally the same in both cases. I find the same mesh values as those in my drawings via finding e0’s halfedge, finding the rest of the halfedges with proper calls to twin() and next(), and then finding the vertices, edges, and faces with calls to vertex(), edge(), and face() on the relevant halfedges. I then created the necessary halfedges, vertices, edges, and faces that would be created when the triangle was split (taking particular care when creating the new vertex m, which I had to set its position equal to the midpoint of the vertices along the split edge). Once I did this, it was as easy as utilizing setNeighbors and halfedge() to reassign pointers just like I had done in my drawing. I would like to note that something that was noticeably different when implementing split when compared to implementing flip is that in split I also had to change the pointers of the twins of the halfedges on the outer edges of the original triangle (an example being h2’s twin) to account for the move of some halfedges to the “inside” of the original triangle. Just like in task 4, I’d say to draw / write everything out first, and then utilize those values in the code to make the process straightforward and easy to read. Also for debugging utilizing this approach, ensure that mesh values stay consistent from transferring what’s written on paper to what’s written in the code.
</p>
<br>


<b>
    Show screenshots of a mesh before and after some edge splits. 
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task5-3.png" align="middle" width="400px"/>
                    <figcaption>Default Viewpoint</figcaption>
                </td>
                <td>
                    <img src="images/task5-4.png" align="middle" width="400px"/>
                    <figcaption>After Edge Splits</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task5-5.png" align="middle" width="400px"/>
                    <figcaption>Different Viewpoint</figcaption>
                </td>
                <td>
                    <img src="images/task5-6.png" align="middle" width="400px"/>
                    <figcaption>After Edge Splits</figcaption>
                </td>
            </tr>
        </table>
    </div>

<br>


<b>
    Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task5-7.png" align="middle" width="400px"/>
                    <figcaption>Default Viewpoint</figcaption>
                </td>
                <td>
                    <img src="images/task5-8.png" align="middle" width="400px"/>
                    <figcaption>After Edge Splits and Edge Flips</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task5-9.png" align="middle" width="400px"/>
                    <figcaption>Different Viewpoint</figcaption>
                </td>
                <td>
                    <img src="images/task5-10.png" align="middle" width="400px"/>
                    <figcaption>After Edge Splits and Edge Flips</figcaption>
                </td>
            </tr>
        </table>
    </div>

<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    When I would attempt to split an edge, all of the faces would suddenly just disappear. I was stuck on this for quite a while and even tried a different way of splitting (which I ended up keeping as it felt cleaner), but was met with the same result. However, after rereading the spec I realized that I overlooked the fact that we had to assign the position of m to be the midpoint of the vertices that made up the split edge, and I had accidentally switched the c and the d vertices in my drawn diagram. After fixing these two issues, my code finally ran as expected!
</p>
<br>


<b>
    If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task5-11.png" align="middle" width="400px"/>
                    <figcaption>Before Boundary Split</figcaption>
                </td>
                <td>
                    <img src="images/task5-12.png" align="middle" width="400px"/>
                    <figcaption>After Boundary Split</figcaption>
                </td>
            </tr>
        </table>
    </div>

<br>


<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
<b>
  Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    I decided to follow the suggestion on the spec and the comments in the code and first computed the new positions of all vertices. To do so, I first looped over all vertices in the mesh, and for each vertex I looped through it’s neighboring vertices and computed a sum of their positions, and then computed the newPosition value for the vertex using the loop subdivision formula for old vertices provided in the spec (also setting the vertex’s isNew value to false). Next I looped over all edges in the mesh, and for each edge I found the vertices of the pair triangles connected through said edge, and utilized their positions to compute the edge’s newPosition value using the loop subdivision formula for new vertices provided in the spec (also setting the edge’s isNew value to false). Before I explain the next step, I want to note that in my edgeSplit function, I altered it a little bit to assign all newly created edges’ isNew values to true, assign the new vertex’s isNew value to true, and set the new vertex’s newPosition value to the split edge’s newPosition value. Back to the overall procedure, in my next step I looped through all edges in the mesh, and for every non-boundary edge whose vertices were both old, I split the edge (effectively preventing splitting newly created edges from each previous split). After this I looped through all edges in the mesh and for every non-boundary edge that was new and had one old and one new vertex, I flipped the edge. Finally, I looped through all vertices in the mesh and assigned each vertex’s position value to its newPosition value, and ended by resetting all isNew values for all vertices and edges to false. As far as implementation tricks go, I tried to assign as many variables (in a reasonable manner) as possible to make code cleaner and to prevent potential changes in pointer values. As far as debugging tricks go, I printed out values throughout the process which helped me to find where things were going wrong, this especially helped when I accidentally made a few for loops start at a mesh’s beginning vertex and run until the mesh’s beginning vertex, effectively making the loop never run at all.
</p>
<br>


<b>
  Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task6-1.png" align="middle" width="400px"/>
                    <figcaption>Default Cube</figcaption>
                </td>
                <td>
                    <img src="images/task6-2.png" align="middle" width="400px"/>
                    <figcaption>Cube with Splits</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task6-3.png" align="middle" width="400px"/>
                    <figcaption>Default Cube After 1 Division</figcaption>
                </td>
                <td>
                    <img src="images/task6-4.png" align="middle" width="400px"/>
                    <figcaption>Cube with Splits After 1 Division</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task6-5.png" align="middle" width="400px"/>
                    <figcaption>Default Cube After 2 Divisions</figcaption>
                </td>
                <td>
                    <img src="images/task6-6.png" align="middle" width="400px"/>
                    <figcaption>Cube with Splits After 2 Divisions</figcaption>
                </td>
            </tr>
        </table>
    </div>

<p>
    Overall, the meshes become much smoother and make curves less jagged, similar to the Phong shading implemented in task 3. However, the difference here is that the addition of more vertices allow for a more accurate depiction of the general shape of the object. However, the vertices that make up the sharp corners and edges tend to move towards the center of the object (as shown in the screenshots), creating a “shrinking” like effect, as well as becoming more “spherical” in nature (this makes sense, as vertices’ new positions are weighted averages of the vertices surrounding them, and sharp corners and edges tend to be made up of vertices that are far apart and thus taking the average reduces the absolute values of their positions). As shown in the screenshots, by pre-splitting some edges of the cube, there are more vertices that are close together along the edges and more vertices close to the corners, which reduce the shrinking effect and make the edges and corners smooth yet still defined.
</p>
<br>


<b>
  Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.
</b>

    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/task6-1.png" align="middle" width="400px"/>
                    <figcaption>Default Cube</figcaption>
                </td>
                <td>
                    <img src="images/task6-7.png" align="middle" width="400px"/>
                    <figcaption>Cube with Symmetric Edges</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task6-3.png" align="middle" width="400px"/>
                    <figcaption>Default Cube After 1 Division</figcaption>
                </td>
                <td>
                    <img src="images/task6-8.png" align="middle" width="400px"/>
                    <figcaption>Cube with Symmetric Edges After 1 Division</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/task6-5.png" align="middle" width="400px"/>
                    <figcaption>Default Cube After 2 Divisions</figcaption>
                </td>
                <td>
                    <img src="images/task6-9.png" align="middle" width="400px"/>
                    <figcaption>Cube with Symmetric Edges After 2 Divisions</figcaption>
                </td>
            </tr>
        </table>
    </div>

<p>
    Yes, we can perform some edge splits across the “faces” of the cube to make the faces symmetric (with edges forming an “X” on the “faces” of the cube) to successfully have the cube subdivide symmetrically. The reason why the default cube becomes slightly asymmetric is because each “face” of the cube only has one edge across it, causing the cube to have protruding points that tend towards a few favored corners when loop subdivision occurs. This makes sense, as only a single edge on the “face” of the cube, means that when the loop subdivision algorithm is run, there is a single split across the single edge on each face which creates groups of vertices close to vertices not connected by single edge, which eventually result in biased pointed corners to create an asymmetric shape. The preprocessing I described earlier helps to alleviate these effects because now there is uniform splitting across the cube (as each “face” of the cube has the same structure of edges, that being the “X” shape they form), meaning newly vertices are evenly distributed across the cube, no longer grouped in favored corners.
</p>
<br>

<h3 align="middle">Link to Webpage</h3>
    <p>https://sarevalo2002.github.io/proj-webpage-template/</p>

<!--
<b>
    If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>
-->

    <!-- Example of including a single figure -->
    <!--
    <div align="middle">
        <img src="images/your_file.png" align="middle" width="50%">
    </div>
    -->

    <!-- Example of including multiple figures -->
    <!--
    <div align="middle">
        <table style="width:100%">
            <tr align="center">
                <td>
                    <img src="images/your_file.png" align="middle" width="400px"/>
                    <figcaption>Level 0</figcaption>
                </td>
                <td>
                    <img src="images/your_file.png" align="middle" width="400px"/>
                    <figcaption>Level 1</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/your_file.png" align="middle" width="400px"/>
                    <figcaption>Level 2</figcaption>
                </td>
                <td>
                    <img src="images/your_file.png" align="middle" width="400px"/>
                    <figcaption>Level 3</figcaption>
                </td>
            </tr>
            <br>
            <tr align="center">
                <td>
                    <img src="images/your_file.png" align="middle" width="400px"/>
                    <figcaption>Level 4</figcaption>
                </td>
            </tr>
        </table>
    </div>
    -->

<!--
<h3 align="middle">Part 7 (Optional, Possible Extra Credit)</h3>
<b>
    Save your best polygon mesh as partsevenmodel.dae in your docs folder and show us a screenshot of the mesh in your write-up.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>

<br>


<b>
    Include a series of screenshots showing your original mesh and your mesh after one and two rounds of subdivision. If you have used custom shaders, include screenshots of your mesh with those shaders applied as well.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Describe what you have done to enhance your mesh beyond the simple humanoid mesh described in the tutorial.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>
-->

</body>
</html>